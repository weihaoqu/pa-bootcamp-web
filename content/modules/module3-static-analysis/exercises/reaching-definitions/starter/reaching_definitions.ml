(* Reaching Definitions Analysis - Forward May-Analysis
 *
 * A definition d of variable v "reaches" a program point p if there is a
 * path from d to p along which v is not redefined. This is a FORWARD
 * analysis because information flows from definitions (earlier in the
 * program) forward to later points.
 *
 * Transfer function (applied forward):
 *   OUT[B] = gen[B] U (IN[B] - kill[B])
 *
 * Merge (at control-flow joins in forward direction):
 *   IN[B] = U OUT[P] for all predecessors P of B
 *
 * This is a "may" analysis with union merge because a definition reaches
 * a point if it MAY arrive along ANY path to that point.
 *)

module StringSet = Set.Make(String)

(** A definition records where a variable is assigned.
    - [def_id]:   unique label for this definition (e.g., "d1")
    - [var_name]: the variable being defined (e.g., "a")
    - [block]:    the basic block that contains this definition (e.g., "B1")
*)
type definition = {
  def_id : string;
  var_name : string;
  block : string;
}

(* compute_gen: Compute the gen set for a given block.
 *
 * The gen set contains the def_ids of definitions that are generated
 * (i.e., created) in this block. If a variable is defined multiple times
 * within the same block, only the LAST definition of that variable is
 * generated, because earlier definitions are immediately killed within
 * the block.
 *
 * @param defs   all definitions in the program
 * @param block  the label of the block to compute gen for
 * @return       StringSet of def_ids generated by this block
 *)
let compute_gen (_defs : definition list) (_block : string) : StringSet.t =
  failwith "TODO: filter definitions by block and return the last def of each variable"

(* compute_kill: Compute the kill set for a given block.
 *
 * The kill set contains def_ids of definitions that are killed by this
 * block. A definition d_i of variable v is killed by block B if B
 * contains a definition of v AND d_i is not in gen[B].
 *
 * In other words: for each variable defined in block B, kill contains
 * all OTHER definitions of that variable (from any block).
 *
 * @param defs   all definitions in the program
 * @param block  the label of the block to compute kill for
 * @return       StringSet of def_ids killed by this block
 *)
let compute_kill (_defs : definition list) (_block : string) : StringSet.t =
  failwith "TODO: for each variable defined in this block, find all other defs of that variable"

(* analyze: Run the reaching definitions forward iterative analysis.
 *
 * Given a CFG represented as (block_label, predecessor_labels) pairs and
 * a list of all definitions, compute the fixed-point solution.
 *
 * Algorithm:
 *   1. Initialize OUT[B] = {} for all blocks
 *   2. Repeat until no OUT set changes:
 *      a. For each block B:
 *         - IN[B]  = union of OUT[P] for all predecessors P of B
 *         - OUT[B] = gen[B] U (IN[B] - kill[B])
 *   3. Return (label, IN[B], OUT[B]) for each block
 *
 * @param cfg   list of (block_label, predecessor_labels) pairs
 * @param defs  all definitions in the program
 * @return      list of (block_label, in_set, out_set) triples
 *)
let analyze
    (_cfg : (string * string list) list)
    (_defs : definition list)
    : (string * StringSet.t * StringSet.t) list =
  failwith "TODO: implement forward iterative fixpoint analysis"
